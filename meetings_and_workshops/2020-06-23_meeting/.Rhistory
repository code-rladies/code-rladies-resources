stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(res.aov, detailed = TRUE),
caption = get_pwc_label(pwc)
)
# summary stats surv
data %>%
group_by(wave) %>%
get_summary_stats(surv, type = "mean_sd")
# boxplot surv
bxp2 <- ggboxplot(data, x = "wave", y = "surv",
add = "point")
bxp2
# test for outliers -- no outliers
# surv
data %>%
group_by(wave) %>%
identify_outliers(surv)
# test normality --
# shapiro test
# surv
data %>%
group_by(wave) %>%
shapiro_test(surv)
# qqplot
# surv
ggqqplot(data, "surv", facet.by = "wave")
# sphericity
# surv
res.aov2 <- anova_test(data = data, surv ~ wave, dv = surv,
wid = id, within = wave)
get_anova_table(res.aov2)
# post hoc tests
# pairwise comparisons
# surv
pwc2 <- data %>%
pairwise_t_test(
surv ~ wave, paired = FALSE,
p.adjust.method = "bonferroni"
)
pwc2
# Visualization: box plots with p-values
pwc2 <- pwc2 %>% add_xy_position(x = "wave")
bxp2 +
stat_pvalue_manual(pwc2) +
labs(
subtitle = get_test_label(res.aov2, detailed = TRUE),
caption = get_pwc_label(pwc2)
)
windows()
get_anova_table(res.aov2)
windows()
pwc <- pwc %>% add_xy_position(x = "wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(res.aov, detailed = TRUE),
caption = get_pwc_label(pwc)
)
windows()
pwc <- pwc %>% add_xy_position(x = "wave")
bxp +
stat_pvalue_manual(pwc) +
labs(
subtitle = get_test_label(res.aov, detailed = TRUE),
caption = get_pwc_label(pwc)
)
d <- rio::import("C:/Users/eakfi/Documents/Sp20/ExperimentalDesign/final/final/WVSCulturalMap.csv")
View(d)
?ggboxplot
# boxplot trad
bxp <- ggboxplot(data, x = "Wave", y = "trad",
add = "point")
# boxplot trad
bxp <- ggboxplot(data, x = "wave", y = "trad",
add = "point")
?identify_outliers
## perform DIF analysis
N <- 2000
library(mirt)
data <- rio::import("C:/Users/eakfi/Documents/Sp20/IRT/HW3/HW3data.csv")
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE, IRTpar = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
library(mirt)
data <- rio::import("C:/Users/eakfi/Documents/Sp20/IRT/HW3/HW3data.csv")
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
install.packages("mirt")
install.packages("mirt")
install.packages("mirt")
install.packages("mirt")
install.packages("mirt")
install.packages("mirt")
install.packages("mirt")
library(mirt)
data <- rio::import("C:/Users/eakfi/Documents/Sp20/IRT/HW3/HW3data.csv")
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
## plot DIF item 2
itemplot(model, 2, type = 'trace')
## plot DIF item 6
itemplot(model, 6, type = 'trace')
#Differential Item Functioning
#Dichotomous DIF using mirt
library(mirt)
set.seed(12345)
a1 <- a2 <- matrix(abs(rnorm(5,1,.3)), ncol=1) # discrimination/slope
d1 <- d2 <- matrix(rnorm(5,0,.7),ncol=1) # intercept
a2[1, ] <- a1[1, ]/3 # a2 will be 1/3 as discriminating as a1; different discriminiation for  item 1
d1[5, ] <- d2[5, ]/4 # d1 will be 1/4 as discriminating as d2; different difficulty for item 5
round(data.frame(a.group1 = a1, a.group2 = a2, d.group1 = d1, d.group2 = d2),2)
itemtype <- rep('dich', nrow(a1))
N <- 1000
dataset1 <- simdata(a1, d1, N, itemtype)
dataset2 <- simdata(a2, d2, N, itemtype)
data <- rbind(dataset1, dataset2)
group <- c(rep('grp1', N), rep('grp2', N)) # assign group labels
model <- multipleGroup(data, 1, group, SE = TRUE) # DIF analysis; one is for unidimensional or one latent trait
coef(model,simplify=T) # separate groups
plot(model, type = 'info') # overall test info; measure precision/reliability
# group 1 is more reliable
plot(model, type = 'trace') # plot trace lines
# some items like item 1 has DIF, but item 3 is basically same
plot(model) # expected total score
# group 1 and group 2 have some differences; look at horizontal differences
# at total of 4 group 1 requires lower theta than group 2 to get score
# biased at test level; easier to do well in group 1
itemplot(model, 1, type = 'trace') #individual item plots
# you can see how DIF shows up on latent trait scale
# for item 1 up until theta = -1 there is no difference
# beyond this there is advantage for group 1
# 1 represents item number
# item 3 has no difference so there is no advantage
itemplot(model, 1, type = 'info') # info plot related to slope
# group 1 is steeper than group 2; item information is different
# item 1 is steeper for group 1 and has better measurement and discrimination
DIF(model, c('a1','d'), plotdif = TRUE) # tell it what parameters you would like to
#Polytomous DIF
#if necessary: install.packages('psych')
library(psych)
data(bfi)
resp.data <- bfi[,c(2:8)] #Columns 1-25 include item response data; here we just use a few items
gender <- as.character(bfi$gender)# the multigroup function has to use character data not numeric
polymod <- multipleGroup(resp.data,1,group=gender, SE=TRUE)
labels <- c("Reference Group","Focal Group") ### Create labels for your groups
#test level DIF plots
ets.plot <- plot(polymod,type='score',theta_lim=c(-4,4)) ### This extracts the data from the object
etsx <- ets.plot[["panel.args"]][[1]][["x"]]
etsx1 <- etsx[1:200]
etsx2 <- etsx[201:400]
etsy <- ets.plot[["panel.args"]][[1]][["y"]]
etsy1<- etsy[1:200]
etsy2 <- etsy[201:400]
etsyd <- etsy1-etsy2
windows(10,6) #Mac users: quartz(10,8) ### This will create a plot in a new window
par(mar=c(4,4,1,1))
layout(matrix(c(1,2,1,3),ncol=2),heights=c(1,3))
plot.new()
text(0.5,0.5,"Reference group compared to focal group",cex=1.25,font=2) ## Change Title
plot(etsx1,etsy1,type='l', main = "A. Expected Total Score", ylab="Score", xlab="Theta",
bty='l',ylim=c(min(etsy1)-.05*(max(etsy2)),max(etsy2)+.05*(max(etsy2))))
lines(etsx2,etsy2,type='l',col=2,lty=2)
legend(-2.5,6,labels,col=c(1,2), lty=1:2,box.lty = 0)
plot(etsx1,etsyd, type='l', main = "B. Test Score Difference", ylab = "Score",
xlab = "Theta", ylim = c(-5,5),bty='l')
abline(h=0,lty=2)
for (i in 1:polymod@Data[["nitems"]]) {
eis.plot <- itemplot(polymod,type='score',theta_lim = c(-4,4), item = i)
eisx <- eis.plot[["panel.args"]][[1]][["x"]]
eisx1 <- eisx[1:200]
eisx2 <- eisx[201:400]
eisy <- eis.plot[["panel.args"]][[1]][["y"]]
eisy1<- eisy[1:200]
eisy2 <- eisy[201:400]
eisyd <- eisy1-eisy2
crc <- itemplot(polymod,type='trace',item=i,theta_lim = c(-4,4))
crc1x <- crc[["panel.args"]][[1]][["x"]]
crc1x1 <- crc1x[1:200]
crc1x2 <- crc1x[201:400]
crc1y <- crc[["panel.args"]][[1]][["y"]]
crc1y1<- crc1y[1:200]
crc1y2 <- crc1y[201:400]
crc2x <- crc[["panel.args"]][[2]][["x"]]
crc2x1 <- crc2x[1:200]
crc2x2 <- crc2x[201:400]
crc2y <- crc[["panel.args"]][[2]][["y"]]
crc2y1<- crc2y[1:200]
crc2y2 <- crc2y[201:400]
crc3x <- crc[["panel.args"]][[3]][["x"]]
crc3x1 <- crc3x[1:200]
crc3x2 <- crc3x[201:400]
crc3y <- crc[["panel.args"]][[3]][["y"]]
crc3y1<- crc3y[1:200]
crc3y2 <- crc3y[201:400]
crc4x <- crc[["panel.args"]][[4]][["x"]]
crc4x1 <- crc4x[1:200]
crc4x2 <- crc4x[201:400]
crc4y <- crc[["panel.args"]][[4]][["y"]]
crc4y1<- crc4y[1:200]
crc4y2 <- crc4y[201:400]
windows(6,7) #Mac users: quartz(6,7)
par(mar=c(4,4,1,1))
layout(matrix(c(1,2,4,1,3,5),ncol=2),heights=c(1,3,3))
plot.new()
text(0.5,0.5,paste0("Reference Group Compared to Focal Group - Item ", i)
,cex=1.5,font=2) ## Change Tipolymode
plot(eisx1,eisy1,type='l', main = "A. Expected Score", ylab="Score", xlab="Theta",
bty='l')
lines(eisx2,eisy2,type='l',col=2,lty=2)
plot(eisx1,eisyd, type='l', main = "B. Item Score Difference", ylab = "Score",
xlab = "Theta", ylim = c(-1,1),bty='l')
abline(h=0)
plot.new()
legend("center",labels,col=c(1,2), lty=1:2,box.lty = 0,cex=1.25)
plot(crc1x1,crc1y1, type='l',main = "C. Categorical Response Curve",
ylab = "Probabpolymodity",xlab="Theta",ylim=c(0,1.01),bty='l')
lines(crc2x1,crc2y1, type='l')
lines(crc3x1,crc3y1, type='l')
lines(crc4x1,crc4y1, type='l')
lines(crc1x2,crc1y2, type='l',col=2,lty=2)
lines(crc2x2,crc2y2, type='l',col=2,lty=2)
lines(crc3x2,crc3y2, type='l',col=2,lty=2)
lines(crc4x2,crc4y2, type='l',col=2,lty=2)
}
library(mirt)
set.seed(12345)
a1 <- a2 <- matrix(abs(rnorm(5,1,.3)), ncol=1) # discrimination/slope
d1 <- d2 <- matrix(rnorm(5,0,.7),ncol=1) # intercept
a2[1, ] <- a1[1, ]/3 # a2 will be 1/3 as discriminating as a1; different discriminiation for  item 1
d1[5, ] <- d2[5, ]/4 # d1 will be 1/4 as discriminating as d2; different difficulty for item 5
round(data.frame(a.group1 = a1, a.group2 = a2, d.group1 = d1, d.group2 = d2),2)
itemtype <- rep('dich', nrow(a1))
N <- 1000
dataset1 <- simdata(a1, d1, N, itemtype)
dataset2 <- simdata(a2, d2, N, itemtype)
data <- rbind(dataset1, dataset2)
group <- c(rep('grp1', N), rep('grp2', N)) # assign group labels
model <- multipleGroup(data, 1, group, SE = TRUE) # DIF analysis; one is for unidimensional or one latent trait
coef(model,simplify=T) # separate groups
plot(model, type = 'info') #
plot(model, type = 'trace') # plot trace lines
# some items like item 1 has DIF, but item 3 is basically same
plot(model) # expected total score
# group 1 and group 2 have some differences; look at horizontal differences
# at total of 4 group 1 requires lower theta than group 2 to get score
# biased at test level; easier to do well in group 1
itemplot(model, 1, type = 'trace') #individual item plots
# you can see how DIF shows up on latent trait scale
# for item 1 up until theta = -1 there is no difference
# beyond this there is advantage for group 1
# 1 represents item number
# item 3 has no difference so there is no advantage
itemplot(model, 1, type = 'info') #
# group 1 is steeper than group 2; item information is different
# item 1 is steeper for group 1 and has better measurement and discrimination
DIF(model, c('a1','d'), plotdif = TRUE) # tell it what parameters you would like to
install.packages("mirt", dependencies = TRUE)
install.packages("mirt", dependencies = TRUE)
library(mirt)
library(mirt)
set.seed(12345)
a1 <- a2 <- matrix(abs(rnorm(5,1,.3)), ncol=1) # discrimination/slope
d1 <- d2 <- matrix(rnorm(5,0,.7),ncol=1) # intercept
a2[1, ] <- a1[1, ]/3 # a2 will be 1/3 as discriminating as a1; different discriminiation for  item 1
d1[5, ] <- d2[5, ]/4 # d1 will be 1/4 as discriminating as d2; different difficulty for item 5
round(data.frame(a.group1 = a1, a.group2 = a2, d.group1 = d1, d.group2 = d2),2)
itemtype <- rep('dich', nrow(a1))
N <- 1000
dataset1 <- simdata(a1, d1, N, itemtype)
dataset2 <- simdata(a2, d2, N, itemtype)
data <- rbind(dataset1, dataset2)
group <- c(rep('grp1', N), rep('grp2', N)) # assign group labels
model <- multipleGroup(data, 1, group, SE = TRUE) # DIF analysis; one is for unidimensional or one latent trait
coef(model,simplify=T) # separate groups
plot(model, type = 'info') # overall test info; measure precision/reliability
# group 1 is more reliable
plot(model, type = 'trace') # plot trace lines
# some items like item 1 has DIF, but item 3 is basically same
plot(model) # expected total score
install.packages(c("rio", "mokken"), dependencies = TRUE)
install.packages("mokken")
install.packages("gifski")
#Linking & Equating
#if necessary: install.packages('equateIRT')
library(equateIRT)
library(mirt)
data <- rio::import("C:/Users/eakfi/Documents/Sp20/IRT/HW3/HW3data.csv")
## perform DIF analysis
N <- 2000
group <- c(rep('English', N), rep('Swedish', N))
model <- multipleGroup(data, 1, group, SE = TRUE)
coef(model,simplify=T)
DIF(model, c('d'), plotdif = TRUE)
?DIF
?plot
#Differential Item Functioning
#Dichotomous DIF using mirt
library(mirt)
set.seed(12345)
a1 <- a2 <- matrix(abs(rnorm(5,1,.3)), ncol=1) # discrimination/slope
d1 <- d2 <- matrix(rnorm(5,0,.7),ncol=1) # intercept
a2[1, ] <- a1[1, ]/3 # a2 will be 1/3 as discriminating as a1; different discriminiation for  item 1
d1[5, ] <- d2[5, ]/4 # d1 will be 1/4 as discriminating as d2; different difficulty for item 5
round(data.frame(a.group1 = a1, a.group2 = a2, d.group1 = d1, d.group2 = d2),2)
itemtype <- rep('dich', nrow(a1))
N <- 1000
dataset1 <- simdata(a1, d1, N, itemtype)
dataset2 <- simdata(a2, d2, N, itemtype)
data <- rbind(dataset1, dataset2)
group <- c(rep('grp1', N), rep('grp2', N)) # assign group labels
model <- multipleGroup(data, 1, group, SE = TRUE) # DIF analysis; one is for unidimensional or one latent trait
coef(model,simplify=T) # separate groups
plot(model, type = 'info') # overall test info; measure precision/reliability
# group 1 is more reliable
plot(model, type = 'trace') # plot trace lines
getwd()
tinytex::reinstall_tinytex()
0.5878803
sqrt(0.5878803)
sqrt(0.5878803)/sqrt(0.5878803 + (10^2/(5*5)))
sqrt(10^2/(5*5*((1/0.5878803)-1)))
1/(0.5878803^2) - 1
4/1.893491
sqrt(2.1125)
sqrt(5^2/(3*2*((1/0.5878803)-1)))
2.437963/sqrt(2.437963^2 + (5^2/(3*2)))
detectCores()
install.packages(c("dopar", "dorng"))
install.packages(c("doParallel", "doRNG"))
library(doParallel)
library(doRNG)
detectCores()
install.packages("dplyr")
library(dplyr)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("dungtsa/PowerPredictiveBiomarker",force = TRUE)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("dungtsa/PowerPredictiveBiomarker",force = TRUE)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("dungtsa/PowerPredictiveBiomarker",force = TRUE)
if (!require("devtools"))
install.packages("devtools")
devtools::install_github("dungtsa/PowerPredictiveBiomarker",force = TRUE)
install.packages("simr")
library(simr)
?`simr-package`
source('~/.active-rstudio-document', echo=TRUE)
install.packages("backports")
remove.packages("backports", lib="~/R/win-library/4.0")
install.packages("backports")
install.packages("backports", lib="C:/Program Files/R/R-4.0.0/library")
library(backports)
install.packages("backports")
if (packageVersion("devtools") < 1.6) {
install.packages("devtools")
}
devtools::install_github("hadley/lazyeval")
devtools::install_github("hadley/dplyr")
install.packages("dplyr")
install.packages("dplyr")
install.packages("dplyr")
uninstall("dplyr")
install.packages("dplyr", lib="C:/Program Files/R/R-4.0.0/library")
library(utils)
setwd("~/RLadies/plotting")
setwd("~/RLadies/plotting")
# how to import excel
# read in the first worksheet from the workbook myexcel.xlsx
# first row contains variable names
mydata <- read.xlsx("SampleData.xlsx", sheetName = "SalesOrders")
library(xlsx) # excel
?require
install.packages(c("utils", "xlsx", "Hmisc"))
install.packages(c("utils", "xlsx", "Hmisc"))
library(utils) # csv
library(xlsx) # excel
install.packages(c("utils", "xlsx", "Hmisc"))
install.packages(c("utils", "xlsx", "Hmisc"))
setwd("~/RLadies/plotting")
install.packages(c("utils", "xlsx", "Hmisc"))
install.packages(c("utils", "xlsx", "Hmisc"))
library(utils) # csv
library(xlsx) # excel
install.packages("utils")
install.packages("utils")
install.packages("xlsx")
detach("package:utils", unload = TRUE)
require("utils")
require("xlsx") # excel
install.packages("xlsx")
library(xlsx) # excel
library(xlsx) # excel
install.packages("readxl")
install.packages("Hmisc")
library(utils) # csv
library(readxl) # excel
library(Hmisc) # SPSS and SAS
# how to import excel
# read in the first worksheet from the workbook myexcel.xlsx
# first row contains variable names
mydata <- read_excel("SampleData.xlsx", sheetName = "SalesOrders")
# how to import excel
# read in the first worksheet from the workbook myexcel.xlsx
# first row contains variable names
mydata <- read_excel("SampleData.xlsx", sheet = "SalesOrders")
View(mydata)
?plot
hist(mydata$Item,main="Distribution of Items",xlab="Items")
hist(mydata$Units,main="Distribution of Units Items",xlab="Units")
hist(mydata$`Unit Cost`,main="Distribution of Cost of Items",xlab="Cost")
hist(mydata$Units,main="Distribution of Number of Units",xlab="Units")
boxplot(mydata$`Unit Cost`, ylab = "Unit Cost")
plot(mydata$Units, mydata$`Unit Cost`)
cor(mydata$Units, mydata$`Unit Cost`)
qqnorm(mydata$Total)
qqline(mydata$Total)
qqnorm(mydata$Total)
qqline(mydata$Total)
box95*1.99
95*1.99
qqnorm(mydata$Total,
main="Normal Q-Q Plot of Total Cost",
xlab="Theoretical Quantiles of Total Cost",
ylab="Sample Quantiles of Total Cost")
qqline(mydata$Total)
plot(mydata$Units, mydata$`Unit Cost`)
cor(mydata$Units, mydata$`Unit Cost`)
?plot
plot(mydata$Units, mydata$`Unit Cost`, xlab = "Number of Units", ylab = "Unit Cost")
cor(mydata$Units, mydata$`Unit Cost`)
plot(mydata$Units, mydata$`Unit Cost`, xlab = "Number of Units", ylab = "Unit Cost", main = "correlation between Number of Units and Cost per Unit")
cor(mydata$Units, mydata$`Unit Cost`)
plot(mydata$Units, mydata$`Unit Cost`, xlab = "Number of Units", ylab = "Unit Cost", main = "Correlation between Number of Units and Cost per Unit")
cor(mydata$Units, mydata$`Unit Cost`)
plot(mydata$Units, mydata$Total, xlab = "Number of Units",
ylab = "Total Cost", main = "Correlation between Number of Units and Total Cost")
cor(mydata$Units, mydata$Total)
plot(mydata$`Unit Cost`, mydata$Total, xlab = "Cost per Unit",
ylab = "Total Cost", main = "Correlation between Cost per Unit and Total Cost")
cor(mydata$`Unit Cost`, mydata$Total)
boxplot(mydata$Units, ylab = "Number of Units")
boxplot(mydata$Units, ylab = "Number of Units", main = "Boxplot of Number of Units Sold")
boxplot(mydata$`Unit Cost`, ylab = "Unit Cost",
main = "Box Plot of Cost per Unit")
faithful
?lm
# create linear model
eruption.lm = lm(eruptions ~ waiting, data=faithful)
# calculate residuals
eruption.res = resid(eruption.lm)
# residual plot of residuals against observed values of waiting
plot(faithful$waiting, eruption.res,
ylab="Residuals", xlab="Waiting Time",
main="Old Faithful Eruptions")
abline(0, 0)
par(mfrow = c(2, 2))
plot(model)
par(mfrow = c(2, 2))
plot(eruption.lm)
# Residual vs Fitted
plot(eruption.lm, 1)
# Normal QQ
plot(eruption.lm, 2)
# Scale-Location
plot(eruption.lm, 3)
# Residuals vs Leverage
plot(eruption.lm, 4)
# Residual vs Fitted
plot(eruption.lm, 1)
# Normal QQ
plot(eruption.lm, 2)
# Scale-Location
plot(eruption.lm, 3)
# Residuals vs Leverage
plot(eruption.lm, 4)
# creates space that will have 4 spaces
par(mfrow = c(2, 2))
#assumption checking plots
plot(eruption.lm)
